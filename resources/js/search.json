[[{"l":"Univalle móvil"}],[{"l":"Getting started"},{"i":"set-up","l":"Set up \uD83D\uDE80","p":["Para poner el proyecto en marcha y correr la app, necesitarás:Para poner el proyecto en marcha y correr la app, necesitarás:","Instalar el SDK de Flutter en tu computadora.","Seleccionar un directorio para el proyecto, navegar a él desde la terminal, y correr:Seleccionar un directorio para el proyecto, navegar a él desde la terminal, y correr:","Así obtendrás el proyecto en tu-directorio/univalle_app/.","Instalar las dependencias, con el comando:Instalar las dependencias, con el comando:","Ya tienes el proyecto completo! Este proyecto tiene principalmente dos \"sabores\": development y production. Para correr el \"sabor\" deseado, ya sea en un emulador o un dispositivo físico, puedes usar la configuración de compilación en VSCode/Android Studio, o correr los siguientes comandos:","Nota:<strong>Nota:</strong> También existe un \"sabor\" También existe un \"sabor\" staging<em>staging</em>, pero está en desuso. De cualquier forma, si lo deseas lo puedes correr con , pero está en desuso. De cualquier forma, si lo deseas lo puedes correr con flutter run --flavor staging --target lib/main_staging.dart<code v-pre>flutter run --flavor staging --target lib/main_staging.dart</code>.."]},{"i":"running-tests","l":"Running Tests \uD83E\uDDEA","p":["Para correr todos los unit y widget tests usa el siguiente comando:","Para ver un reporte de coverage generado puedes usar Para ver un reporte de coverage generado puedes usar IcovIcov..","Este proyecto se basa en flutter_localizations y sigue la guía oficial de internacionalización con Flutter.","Adding Strings<strong>Adding Strings</strong>","Para agregar un nuevo string localizable, abre el archivo app_en.arb en lib/l10n/arb/app_en.arb.","Agrega una nueva llave/valor y una descripción.Agrega una nueva llave/valor y una descripción.","Usa el nuevo string.","Adding Supported Locales<strong>Adding Supported Locales</strong>","Actualiza el CFBundleLocalizations array en el archivo Info.plist en ios/Runner/Info.plist para incluir una nueva localización.","Adding Translations<strong>Adding Translations</strong>","Para cada lozalización soportada, agrega un nuevo archivo ARB en lib/l10n/arb.","Agrega los strings traducidos en el archivo Agrega los strings traducidos en el archivo .arb<code v-pre>.arb</code>::","app_en.arb","app_es.arb<code v-pre>app_es.arb</code>"]}],[{"l":"Architecture","p":["Respecto a la arquitectura, usamos el patrón de arquitectura BLoC, con el paquete flutter_bloc, además de una estructura basada en features (funcionalidades). Se puede visualizar de una mejor manera con el siguiente diagrama:"]},{"l":"Entities","p":["Al hablar de entidades nos estaremos refiriendo a las clases de la lógica de negocio. Son independientes a paquetes, es decir, no debería existir una entidad que tenga como atributo algún componente de Flutter u otro paquete (ni siquiera los colores!).","Algo en común que, por lo general, tendrá cada entidad será un constructor fromJson(), el cual nos permitirá instanciar una entidad a partir de una estructura JSON. Esto es útil, por ejemplo, al realizar peticiones HTTP desde los repositories.","Las entidades no dependen de nada, pero seguramente todo lo demás dependerá de las entidades, tanto los features como los repositories, despues de todo es la lógica de negocio ;) es por eso que en el diagrama se puede ver esa dependencia de cada elemento con las entidades, a través de las flechas de colores.Las entidades no dependen de nada, pero seguramente todo lo demás dependerá de las entidades, tanto los features como los repositories, despues de todo es la lógica de negocio ;) es por eso que en el diagrama se puede ver esa dependencia de cada elemento con las entidades, a través de las flechas de colores. A continuación se encuentra un diagrama de clases, representando las entidades/modelos:A continuación se encuentra un diagrama de clases, representando las entidades/modelos:"]},{"l":"Repositories","p":["Los repositorios son los encargados de obtener datos, absolutamente nada más. Por lo general realizarán peticiones HTTP al servidor, y retornarán la respuesta obtenida utilizando las entities adecuadas.","Puede existir ocasiones en las que se necesite un manejo de petición de datos más compleja, para esos casos se agregarán Data Providers, los cuales se encargarán de hacer las peticiones básicas, y el repositorio asociado se encargará de la complejidad. Puedes ver un poco más sobre esto en la documentación de flutter_bloc.","Si bien los repositorios sólo pueden ser usados a través de BLoC's, un BLoC no puede instanciar un repository, lo recibirá a través de su constructor desde la UI; esto para tener un código testeable respecto a los BLoC's.Si bien los repositorios sólo pueden ser usados a través de BLoC's, un BLoC no puede instanciar un repository, lo recibirá a través de su constructor desde la UI; esto para tener un código testeable respecto a los BLoC's.","Puede que haya ocasiones en las que se necesite usar un sólo repository en muchos BLoC's, pero instanciar un nuevo repository cada vez sería ineficiente! Para solucionar esto se utilizará un Repository Provider, que se encargará de proveer una sola instancia de un repository a su árbol de widgets descendiente."]},{"l":"Features","p":["Un feature es una funcionalidad de la aplicación, por ejemplo, la verificación de conexión a internet, la visualización del horario de un estudiante, el listado de notas, entre otros!","A veces es difícil definir lo que hará un feature y su alcance de manera específica (por ejemplo, un feature de actividades académicas, que engloba las materias, horario y notas, o tres features: materias, hoario y notas), pero esto cuando ocurra se discutirá entre todos para resolverlo ^^A veces es difícil definir lo que hará un feature y su alcance de manera específica (por ejemplo, un feature de actividades académicas, que engloba las materias, horario y notas, o tres features: materias, hoario y notas), pero esto cuando ocurra se discutirá entre todos para resolverlo ^^","Se puede dividir a cada feature en dos: interfaz y lógica. Con la arquitectura BLoC podemos mantener a ambas separadas, siendo la interfaz tanto los widgets personalizados como las vistas/páginas, y la lógica uno o más BLoC's (de preferencia, uno por feature)."]},{"l":"User Interface","p":["Como ya se mencionó antes, la interfaz de usuario contiene los widgets personalizados propios de ese feature y las vistas.","Cabe aclarar que, por lo general, las vistas se estructurarán en dos partes: Cabe aclarar que, por lo general, las vistas se estructurarán en dos partes: page<em><strong>page</strong></em> y y view<em><strong>view</strong></em>, siendo la página en donde se crearán los BLoC Providers, repositories, etc. necesarios, y la vista será la vista como tal, en donde se encuentren los widgets de interfaz (Scaffold, containers, imágenes, texto, etc.) ., siendo la página en donde se crearán los BLoC Providers, repositories, etc. necesarios, y la vista será la vista como tal, en donde se encuentren los widgets de interfaz (Scaffold, containers, imágenes, texto, etc.) ."]},{"l":"BLoC","p":["Bussiness Logic Component, o componentes de lógica de negocio, en español. Nos ayudarán a mantener la interfaz separada de la lógica, a través de un flujo de eventos-estado, en donde la vista envía eventos a un BLoC, y éste emitirá un nuevo estado; dependiendo de este estado, la interfaz puede cambiar.","Entonces, para poder usar BLoC's, primero debemos definir cuáles serán los eventos que nuestra interfaz disparará y qué estados tendrá, además de cómo los eventos afectarán el estado. A partir de esta definición ya se pueden construir los BLoC's con sus respectivos estados, eventos, y por supuesto la lógica :)","Para más información revisa la Para más información revisa la documentación oficial de flutter_blocdocumentación oficial de flutter_bloc.."]}],[{"l":"Folder structure","p":["¿Cómo reflejamos la arquitectura en la estructura de carpetas del proyecto? Hablaremos sobre eso en esta sección :)"]},{"l":"Before starting","p":["Por encima, encontrarás que el proyecto tiene la misma estructura que cualquier proyecto nuevo creado con el CLI de Flutter, sin embargo hay algunas cosas diferentes que explicaremos a continuación:Por encima, encontrarás que el proyecto tiene la misma estructura que cualquier proyecto nuevo creado con el CLI de Flutter, sin embargo hay algunas cosas diferentes que explicaremos a continuación:"]},{"l":"Folder .github","p":["En esta carpeta se encuentran los workflows usados por GitHub Actions, por ahora sólo se tienen dos: main.yaml y retype-action.yml:","main.yaml:<strong><code v-pre>main.yaml</code>:</strong> utilizando very_good_workflows, nos ayudará a analizar el código cada vez que se hace un push o un pull request al repositorio de GitHub, tomando en cuenta principalmente el estilo de código, que todos los tests pasen y que se cumpla con un 75% de coverage. utilizando very_good_workflows, nos ayudará a analizar el código cada vez que se hace un push o un pull request al repositorio de GitHub, tomando en cuenta principalmente el estilo de código, que todos los tests pasen y que se cumpla con un 75% de coverage.","retype-action.yml: generará la documentación del proyecto y la publicará en GitHub pages, utilizando la librería Retype y el paquete Dardoc; también contiene algunos pasos adicionales para corregir la estructura de la documentación.","Además, también se encuentra el template para los pull requests, el cual nos ayudará a describir mejor nuestros cambios y especificar qué tipo de cambios hemos realizado.Además, también se encuentra el template para los pull requests, el cual nos ayudará a describir mejor nuestros cambios y especificar qué tipo de cambios hemos realizado."]},{"i":"files-libmain_flavordart","l":"Files lib/main_flavor.dart","p":["Como se mencionó en la anterior sección, el proyecto cuenta con 2 \"sabores\" principales, development y production, el archivo de arranque para cada sabor son los archivos main_ seguidos del nombre del sabor, como ser main_development.dart y main_production.dart, lo cual nos permite separar nuestros ambientes de trabajo según la etapa en la que nos encontramos.","Por defecto se correrá el archivo Por defecto se correrá el archivo main_development.dart<code v-pre>main_development.dart</code>.."]},{"i":"file-libbootstrapdart","l":"File lib/bootstrap.dart","p":["No es necesario prestar mucha atención a este archivo, pero vale la pena saber por qué está ahí:","Al utilizar el patrón de arquitectura BLoC, podemos saber el estado de la aplicación en todo momento, lo cual es muy conveniente al momento de debuggear o verificar que todo funciona como esperamos que funcione. Sin embargo, no se puede sólo saber el estado de la aplicación sin más, se necesita hacer un poco de configuración, de la cual se encarga este archivo :)Al utilizar el patrón de arquitectura BLoC, podemos saber el estado de la aplicación en todo momento, lo cual es muy conveniente al momento de debuggear o verificar que todo funciona como esperamos que funcione. Sin embargo, no se puede sólo saber el estado de la aplicación sin más, se necesita hacer un poco de configuración, de la cual se encarga este archivo :)","Dentro de bootstrap.dart rodeamos toda nuestra app en un Bloc Observer, el cual nos permitirá saber el estado de nuestra app imprimiéndolo en la consola según el tipo de cambio en el estado, ya sea cuando el estado simplemente cambia o cuando ocurre algún error."]},{"i":"folder-libl10n","l":"Folder lib/l10n","p":["En esta carpeta de guardarán todos los strings usados dentro de la app, permitiendo la internacionalización de la misma.En esta carpeta de guardarán todos los strings usados dentro de la app, permitiendo la internacionalización de la misma. Por ahora sólo se la desarrollará en español, por lo que esta carpeta está en desuso, pero si en algún momento se desea agregar el inglés o portugués, está lista para ser usada!Por ahora sólo se la desarrollará en español, por lo que esta carpeta está en desuso, pero si en algún momento se desea agregar el inglés o portugués, está lista para ser usada!"]},{"i":"folder-libapp","l":"Folder lib/app","p":["Simplemente una abstracción para inicializar el Material App usado por al aplicación, además de definir las rutas, para mantenerlo separado del resto de la funcionalidad de la aplicación y así evitar desorden."]},{"l":"Architecture reflected in folder structure"},{"l":"Features","p":["Las funcionalidades de la app, una carpeta por funcionalidad. Por lo general, cada feature tendrá sus widgets, páginas y BLoC, pero puede haber casos en los que no tenga páginas, o no tenga widgets. Sin embargo, casi siempre (por no decir siempre) cada feature tendrá un BLoC.","Pages:<strong>Pages:</strong> Contendrá los archivos para cada página, sin importar si es sólo una o son más. Una página en realidad es un concepto más orientado al diseño, como una pantalla, y al ser intuitivo se lo manejará en el proyecto en el proyecto. Sin embargo, para estructurar de forma adecuada una página y no tenga conflictos con los widgets ni el bloc, cada página se dividirá en dos widgets: Contendrá los archivos para cada página, sin importar si es sólo una o son más. Una página en realidad es un concepto más orientado al diseño, como una pantalla, y al ser intuitivo se lo manejará en el proyecto en el proyecto. Sin embargo, para estructurar de forma adecuada una página y no tenga conflictos con los widgets ni el bloc, cada página se dividirá en dos widgets: page<code v-pre>page</code> y y view<code v-pre>view</code>..","Page: Un widget cuya función será sólo inicializar los repositories y bloc's necesarios, ya sea usando un BlocProvider o un RepositoryProvider. Tendrá como child al view de la página.","View:<em>View:</em> La funcionalidad de este widget será dibujar la pantalla como tal, usando los componentes/widgets necesarios. Está oriendtado a sólo la vista, sin preocuparse de los repositories o bloc's. La funcionalidad de este widget será dibujar la pantalla como tal, usando los componentes/widgets necesarios. Está oriendtado a sólo la vista, sin preocuparse de los repositories o bloc's.","Widgets: Los widgets/componentes pertenecientes al feature, que serán usados sólo por ese feature.","Bloc:<strong>Bloc:</strong> El Bussiness Logic Object perteneciente al feature, con sus respectivos estados, eventos y el bloc como tal. El Bussiness Logic Object perteneciente al feature, con sus respectivos estados, eventos y el bloc como tal."]},{"l":"Data","p":["Providers: Contendrá diferentes archivos y clases de Providers. Éstos estarán encargados de hacer peticiones en crudo a la API Rest, una petición por método, un provider puede tener varios métodos.","Repositories:<strong>Repositories:</strong> Contendrá diferentes archivos y clases de Repositories. Éstos estarán encargados de llamar a los providers a hacer peticiones y retornar los datos listos para utilizar, cada método puede hacer una o más llamadas a uno o más providers, lo necesario para retornar los datos listos para ser usados. Contendrá diferentes archivos y clases de Repositories. Éstos estarán encargados de llamar a los providers a hacer peticiones y retornar los datos listos para utilizar, cada método puede hacer una o más llamadas a uno o más providers, lo necesario para retornar los datos listos para ser usados."]},{"l":"Models","p":["Las clases de la lógica de negocio, por lo general, una clase por archivo."]}],[{"l":"Adding new features"},{"l":"Defining feature","p":["Para agregar un nuevo feature, se seguirá el siguiente flujo:Para agregar un nuevo feature, se seguirá el siguiente flujo:","Se crea un card en Trello (o se utiliza uno ya existente) en la columna Backlog. Éste card tendrá la etiqueta feature. En caso de ser algo general y no tan específico (ej.: la navegación, conexión a internet), se agregará también la etiqueta general:","Dentro del card, se agrega una descripción detallando el feature, como también el flujo de éste. Con flujo nos referimos a los pasos a seguir por el usuario para utilizar el feature:Dentro del card, se agrega una descripción detallando el feature, como también el flujo de éste. Con flujo nos referimos a los pasos a seguir por el usuario para utilizar el feature:","Por comodidad y para aclarar las ideas, se puede agregar una lista de tareas al card, con los pasos a seguir para completar el desarrollo del feature:","En caso de que el feature tenga mockups, éstos deben adjuntarse al card a través de Zeplin:En caso de que el feature tenga mockups, éstos deben adjuntarse al card a través de Zeplin:","Se agrega a los encargados del feature al card."]},{"l":"Developing feature","p":["Cuando el feature empiece a desarrollarse, éste seguirá el siguiente flujo:Cuando el feature empiece a desarrollarse, éste seguirá el siguiente flujo:","Como se utiliza GitFlow como branching model, al iniciar un nuevo feature el encargado del desarrollo del feature debe crear una nueva rama para éste en el repositorio, con el siguiente formato:","feature/ #item - título significativo<code v-pre>feature/ #item - título significativo</code>","En donde:","#item<strong>#item</strong> es el número del card perteneciente al feature en Trello. es el número del card perteneciente al feature en Trello.","título significativo es el título del feature, debe ser lo suficientemente largo o corto para expresar claridad.","Por ejemplo, en el feature:Por ejemplo, en el feature: El nombre de su rama será:El nombre de su rama será: feature/15-navigation<strong><code v-pre>feature/15-navigation</code></strong>","Se mueve el card del feature a la columna/etapa Development. Siguiendo la arquitectura, al empezar a desarrollar el feature, se debe crear una carpeta dentro de lib/ con el nombre del feature (ej.: lib/connectivity/) y realizar su desarrollo dentro de esta carpeta.","Cuando el desarrollo del feature termine, se ha de escribir los tests correspondientes al feature y el card pasará a la columna/etapa Cuando el desarrollo del feature termine, se ha de escribir los tests correspondientes al feature y el card pasará a la columna/etapa Testing<strong>Testing</strong>. Para que esta etapa se considere terminada, debe tener un coverage de mínimo 80%, aunque lo . Para que esta etapa se considere terminada, debe tener un coverage de mínimo 80%, aunque lo ideal es el 100%<strong>ideal es el 100%</strong>","Una vez terminada la etapa de testing, se procede con la etapa de documentación y se mueve el card a la respectiva columna ( Documentation). En esta etapa se ha de agregar la documentación necesaria para que los demás miembros del equipo entiendan el funcionamiento del feature y también puedan trabajar fácilmente con él en caso de que lo necesiten. Se puede encontrar más info sobre cómo escribir documentación en esta sección.","Terminada la etapa de documentación, el código está listo para subirse. Se creará un pull request desde la rama del feature hacia la rama Terminada la etapa de documentación, el código está listo para subirse. Se creará un pull request desde la rama del feature hacia la rama develop<strong>develop</strong>, con una descripción de lo que se trabajó. Luego de crear el pull request, el proceso de análisis automático se disparará. En caso de que el análisis no acepte el pull request, se debe seguir trabajando en el feature hasta que este proceso lo apruebe. En caso de que el análisis apruebe el pull request, el feature pasará a la etapa de , con una descripción de lo que se trabajó. Luego de crear el pull request, el proceso de análisis automático se disparará. En caso de que el análisis no acepte el pull request, se debe seguir trabajando en el feature hasta que este proceso lo apruebe. En caso de que el análisis apruebe el pull request, el feature pasará a la etapa de Code Review<strong>Code Review</strong>..","Dentro de la etapa Code Review, el desarrollador del feature ha de esperar a que su código sea revisado y aprobado por al menos dos personas del equipo, denominadas reviewers. En caso de que los reviewers no aprueben el código, el desarrollador debe seguir con el feature hasta que éste sea aprobado.","Una vez el código es aprobado en el code review, el feature es integrado a la rama Una vez el código es aprobado en el code review, el feature es integrado a la rama develop<em>develop</em> y oficialmente está terminado! Ahora se puede mover su card a la columna y oficialmente está terminado! Ahora se puede mover su card a la columna Done<strong>Done</strong>..","Cabe recalcar que en caso de que se encuentren fallos o bugs, un feature siempre puede ser re-abierto, y el proceso descrito anteriormente volverá a iniciar, hasta que el bug sea resuelto. La única diferencia será el nombre de la rama, en donde en lugar de feature/, será fix/."]}],[{"l":"About documentation","p":["Al escribir documentación, ésta debe estar redactada de forma clara y con la información necesaria para que los miembros del equipo entiendan lo que se busca redactar y puedan trabajar fácilmente.","Principalmente se busca tener la documentación escrita manualmente en archivos Principalmente se busca tener la documentación escrita manualmente en archivos .md<code v-pre>.md</code>, los cuales serán ubicados dentro del directorio , los cuales serán ubicados dentro del directorio docs/<code v-pre>docs/</code> para su posterior generación en la web page. para su posterior generación en la web page."]},{"l":"Documenting code","p":["En le caso del código, se escribirá documentación en línea a través de comentarios, en inglés, explicando cada clase, método, etc. que utiliza el feature. Se puede encontrar una guía de cómo escribir documentación en línea en Dart aquí, que si bien no es la regla, es bueno tomarla en cuenta.","Para la generación de documentación en línea, se utiliza Dartdoc, el cual se basa en librerías para documentar y agrupar clases, archivos, etc. Por lo que, en el caso de documentar features, cada feature debe tener una librería declarada en el archivo barrel de su carpeta, con su respectiva descripción. Por ejemplo:"]}],[{"l":"Connectivity","p":["Verifica el estado de la conexión a internet."]},{"l":"Workflow","p":["En cuanto la aplicación se inicia, se ha de verificar en todo momento el estado de la conexión a internet, ya que la necesita para su funcionamiento.En cuanto la aplicación se inicia, se ha de verificar en todo momento el estado de la conexión a internet, ya que la necesita para su funcionamiento. Si el dispositivo pierde la conexión a internet, se mostrará una ventana emergente (dialog) informando de la pérdida de conexión y bloqueando el uso de la app. Dicho mensaje desaparecerá cuando la conexión a internet se recupere, además, también se mostrará un snackbar informando que la conexión ha sido recuperada.Si el dispositivo pierde la conexión a internet, se mostrará una ventana emergente (dialog) informando de la pérdida de conexión y bloqueando el uso de la app. Dicho mensaje desaparecerá cuando la conexión a internet se recupere, además, también se mostrará un snackbar informando que la conexión ha sido recuperada."]},{"l":"Behaviour","p":["Se hace uso del package connectivity_plus para la verificación de conexión.","Se reciben los eventos Se reciben los eventos Requested<code v-pre>Requested</code>, , Lost<code v-pre>Lost</code> y y Retrieved<code v-pre>Retrieved</code>..","El evento Requested se dispara al iniciar la aplicación, para inicializar la verificación de conexión. Al recibir este evento, el bloc hace una llamada inicial de verificación y se suscribe al stream del objeto Connectivity del package connectivity_plus para escuchar los cambios en la conexión.","Los eventos Lost y Retrieved informan sobre el cambio de conexión, son disparados por el objeto Connectivity del package connectivity_plus cuando ocurre dicho cambio.Los eventos Lost y Retrieved informan sobre el cambio de conexión, son disparados por el objeto Connectivity del package connectivity_plus cuando ocurre dicho cambio.","Se retornan los estados Initial, Loading, Connected y Disconnected.","Initial<code v-pre>Initial</code> es el estado inicial del bloc al ser creado y no recibir ningún evento. es el estado inicial del bloc al ser creado y no recibir ningún evento.","Loading se retornará luego de recibir el evento Requested y antes de recibir algún evento sobre el estado de la conexión, refleja que la verificación de conectividad está cargando.","Connected<code v-pre>Connected</code> y y Disconnected<code v-pre>Disconnected</code> son retornados luego de los eventos son retornados luego de los eventos Lost<code v-pre>Lost</code> y y Retrieved<code v-pre>Retrieved</code>, para que la interfaz sepa del estado de la conexión y cambie de acuerdo a ésta., para que la interfaz sepa del estado de la conexión y cambie de acuerdo a ésta."]},{"l":"About user interface","p":["Respecto a la interfaz, los eventos que enviará y los estados que recibirá, están los siguientes puntos a considerar:","Al iniciar la aplicación se instancia un Al iniciar la aplicación se instancia un ConnectivityBloc<code v-pre>ConnectivityBloc</code> y se envía el evento y se envía el evento Requested<code v-pre>Requested</code>..","Al recibir el estado Disconnected, se mostrará el dialog ConnectivityLostDialog, el cual informa sobre el estado de la conexión (es decir, sin conexión) y bloquea el uso de la app.","Al recibir el estado Al recibir el estado Connected<code v-pre>Connected</code> luego de un luego de un Disconnected<code v-pre>Disconnected</code>, el dialog anterior se cerrará y desbloqueará la app, además se mostrará un snackbar informando que la conexión ha sido recuperada., el dialog anterior se cerrará y desbloqueará la app, además se mostrará un snackbar informando que la conexión ha sido recuperada.","Al recibir el estado Connected al principio, no habrá cambios y la app funcionará con normalidad hasta que un nuevo estado sea recibido."]}],[{"l":"Navigation","p":["Administración de la navegación en la aplicación."]},{"l":"Generated routes","p":["Las rutas principales de la aplicación, declaradas en la clase Las rutas principales de la aplicación, declaradas en la clase AppRouter<code v-pre>AppRouter</code>. Por ahora existen las siguientes:. Por ahora existen las siguientes:","/ o default: la cual es la ruta principal y por defecto de la app, la cual redirige a la RootPage, en donde se encuentra la estructura principal para la navegación a través de la barra de navegación inferior.","/login<code v-pre>/login</code>: enruta hacia la página de inicio de sesión.: enruta hacia la página de inicio de sesión.","/procedures: enruta hacia la página de trámites / tipos de trámites.","Dentro de cada ruta se inicializan los Blocs necesarios en todas las rutas de la aplicación, por ejemplo:Dentro de cada ruta se inicializan los Blocs necesarios en todas las rutas de la aplicación, por ejemplo:","ConnectivityBloc, para verificar la conexión a internet, es necesario en todas las rutas, ya que se ha de verificar la conexión en todo momento.","En lugar de instanciar nuevos objetos de En lugar de instanciar nuevos objetos de ConnectivityBloc<code v-pre>ConnectivityBloc</code> en cada ruta, o peor aún, instanciar uno nuevo en cada página; es más eficiente manejar una sola instancia de Connectivity BlocProvider para todas las rutas y así evitar la instanciación de objetos innecesarios. en cada ruta, o peor aún, instanciar uno nuevo en cada página; es más eficiente manejar una sola instancia de Connectivity BlocProvider para todas las rutas y así evitar la instanciación de objetos innecesarios.","Para esto, se maneja una sola instancia de ConnectivityBloc dentro de la clase AppRouter, y con BlocProvider.value() se provee esta instancia a cada ruta. BlocProvider.value() toma un Bloc ya existente y lo provee, por lo que utilizarlo es conveniente en esta situación en la que sólo queremos una instancia para todas las rutas."]},{"l":"Bottom navigation bar","p":["La barra de navegación inferior es la forma principal de navegar entre páginas. Se encuentra dentro de RootView y administra su estado utilizando un NavigationCubit, el cual es instanciado y proveído desde La barra de navegación inferior es la forma principal de navegar entre páginas. Se encuentra dentro de RootView y administra su estado utilizando un NavigationCubit, el cual es instanciado y proveído desde RootPage<code v-pre>RootPage</code>..","Actualmente se cuenta con cuatro páginas principales: Inicio, Académica, Pagos y Perfil. Cada una se traduce en un elemento de la barra de navegación."]},{"l":"Behaviour","p":["Para el manejo de estado de la barra de navegación inferior y por ende, el cambio de interfaz al hacer click en un elemento de ésta, se utiliza un Para el manejo de estado de la barra de navegación inferior y por ende, el cambio de interfaz al hacer click en un elemento de ésta, se utiliza un NavigationCubit<code v-pre>NavigationCubit</code>..","El estado inicial de NavigationCubit es NavigationHome, que se traduce en la página Home siendo la página inicial de la app.","NavigationCubit<code v-pre>NavigationCubit</code> contiene el método contiene el método changePage()<code v-pre>changePage()</code>, el cual recibe el índice de la página a la que se está navegando. Este método mapea el índice con el estado que refleja la página correspondiente (de acuerdo al orden de los elementos en la barra de navegación) y lo emite. Por ejemplo:, el cual recibe el índice de la página a la que se está navegando. Este método mapea el índice con el estado que refleja la página correspondiente (de acuerdo al orden de los elementos en la barra de navegación) y lo emite. Por ejemplo:","changePage(0) = emits NavigationHome, ya que la página Home o Inicio es la primera en la barra de navegación.","changePage(3) = emits NavigationProfile<code v-pre>changePage(3) =&gt; emits NavigationProfile</code>, ya que la página Profile o Perfil es la cuarta en la barra de navegación., ya que la página Profile o Perfil es la cuarta en la barra de navegación.","La interfaz, al recibir el nuevo estado, retorna la página correspondiente a éste.","Además, cada estado contiene un índice, el cual es leído por la barra de navegación para actualizar su elemento seleccionado:Además, cada estado contiene un índice, el cual es leído por la barra de navegación para actualizar su elemento seleccionado:"]},{"l":"Bottom sheet menu","p":["El menú emergente, el cual se abre desde el ícono a la derecha del tool bar, permite la navegacion a las rutas \"secundarias\" de la app:","Biblioteca (Biblioteca ( explora la biblioteca<em>explora la biblioteca</em>))","Documentos ( revisa tus documentos)","Trámites (Trámites ( conoce los tipos de trámites<em>conoce los tipos de trámites</em>))","Descuentos ( conoce tus descuentos)","Lugares (Lugares ( explora el campus<em>explora el campus</em>))","Para esto, utiliza las rutas de onGeneratedRoute en AppRouter y navega a cada pantalla a través de Navigator.pushNamed()."]}],[{"i":"#","p":["General diagram for app architecture"]},{"l":"Overview","p":["In simple words, below we can find the application architecture diagramIn simple words, below we can find the application architecture diagram","Mainly we have the pages, and each page is a screen that will be presented to the user (Ex.: Log in page, Home page, User profile page, etc.).","A page can have one or more features (Ex.: Home page has three features: next class, which is related to the schedule; average grade per course, which is related to courses and enrollment; and pending payments, related to the payments.).A page can have one or more features (Ex.: Home page has three features: next class, which is related to the schedule; average grade per course, which is related to courses and enrollment; and pending payments, related to the payments.).","Every feature has its ui (widgets), its BLoC and its definition of events and state to use with the BLoC."]}],[{"i":"#","p":["Diagram for business logic classes"]},{"l":"Class diagram"},{"i":"courses-schedule-and-grades","l":"Courses, schedule and grades"},{"l":"Library and books"}]]